---
features:
  - |
    Gradient Framework. 
    :class:`qiskit.operators.gradients`
    Given an operator that represents either a quantum state resp. an expectation value, the gradient framework enables
    the evaluation of gradients, natural gradients, Hessians, as well as the Quantum Fisher Information.

    Suppose a parameterized quantum state `|ψ(θ)〉 = V(θ)|ψ〉` with input state `|ψ〉` and parametrized Ansatz `V(θ)`,
    and an Operator `O(ω)`.

    Gradients: We want to compute :math:`d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω`
    resp. :math:`d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ`
    resp. :math:`d⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ`.

    The last case corresponds to the gradient w.r.t. the sampling probabilities of `|ψ(θ)`.
    These gradients can be computed with different methods, i.e. a parameter shift, a linear combination of unitaries
    and a finite difference method.

    Examples::

            x = Parameter('x')
            ham = x * X
            a = Parameter('a')

            q = QuantumRegister(1)
            qc = QuantumCircuit(q)
            qc.h(q)
            qc.p(params[0], q[0])
            op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

            value_dict = {x: 0.1, a: np.pi / 4}

            ham_grad = Gradient(grad_method='param_shift').convert(operator=op, params=[x])
            ham_grad.assign_parameters(value_dict).eval()

            state_grad = Gradient(grad_method='lin_comb').convert(operator=op, params=[a])
            state_grad.assign_parameters(value_dict).eval()

            prob_grad = Gradient(grad_method='fin_diff').convert(operator=CircuitStateFn(primitive=qc, coeff=1.),
                                                                 params=[a])
            prob_grad.assign_parameters(value_dict).eval()

    Hessians: We want to compute :math:`d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dω^2`
    resp. :math:`d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ^2`
    resp. :math:`d^2⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθdω`
    resp. :math:`d^2⟨ψ(θ)|i〉⟨i|ψ(θ)〉/ dθ^2`.

    The last case corresponds to the Hessian w.r.t. the sampling probabilities of `|ψ(θ)`.
    Just as the first order gradients, the Hessians can be evaluated with different methods, i.e. a parameter shift, a
    linear combination of unitaries and a finite difference method.
    Given a tuple of parameters ``Hessian().convert(op, param_tuple)`` returns the value for the second order
    derivative.
    If a list of parameters is given ``Hessian().convert(op, param_list)`` returns the full Hessian for all the given
    parameters according to the given parameter order.

    QFI: The Quantum Fisher Information `QFI` is a metric tensor which is representative for the representation capacity
    of a parameterized quantum state `|ψ(θ)〉 = V(θ)|ψ〉` generated by an input state `|ψ〉` and a parametrized Ansatz
    `V(θ)`.
    The entries of the `QFI` for a pure state read :math:`[QFI]kl= Re[〈∂kψ|∂lψ〉−〈∂kψ|ψ〉〈ψ|∂lψ〉] * 4`.

    Just as for the previous derivative types, the QFI can be computed using different methods: a full representation
    based on a linear combination of unitaries implementation, a block-diagonal and a diagonal representation based on
    an overlap method.

    Examples::

            q = QuantumRegister(1)
            qc = QuantumCircuit(q)
            qc.h(q)
            qc.p(params[0], q[0])
            op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)

            value_dict = {x: 0.1, a: np.pi / 4}
            qfi = QFI('lin_comb_full').convert(operator=CircuitStateFn(primitive=qc, coeff=1.), params=[a])
            qfi.assign_parameters(value_dict).eval()


    The combination of the QFI and the gradient lead to a special form of a gradient, namely

    NaturalGradients: The natural gradient is a special gradient method which rescales a gradient w.r.t. a state
    parameter with the inverse of the corresponding Quantum Fisher Information (QFI)
    :math:`QFI^-1 d⟨ψ(θ)|O(ω)|ψ(θ)〉/ dθ`.
    Hereby, we can choose a gradient as well as a QFI method and a regularization method which is used together with a
    least square solver instead of exact invertion of the QFI:

    Examples::
    
            op = ~StateFn(ham) @ CircuitStateFn(primitive=qc, coeff=1.)
            nat_grad = NaturalGradient(grad_method='lin_comb, qfi_method='lin_comb_full', \
                                       regularization='ridge').convert(operator=op, params=params)

    The gradient framework is also compatible with the optimizers from `qiskit.aqua.components.optimizers`. The
    derivative classes come with a `gradient_wrapper()` function which returns the corresponding callable.